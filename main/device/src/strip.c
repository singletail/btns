#include "strip.h"

#define PI 3.14159265358979323846

#define STRIP_MAX_STRIPS 4
#define STRIP_NUM_COLORS 3

strip_t *strips[STRIP_MAX_STRIPS] = {NULL};

const strip_conf_t strip_conf = {
    .num_strips = STRIP_NUM_STRIPS,
    .num_colors = 3,
    .clock_source = SOC_MOD_CLK_APB,
    .resolution_hz = RES_HZ,
    .blk_rmt = 48,      // Minimum required by ESP-IDF
    .blk_dma = 64,      // Keep this reasonably small but larger than minimum
    .queue_rmt = 1,     // Minimal queue size
    .queue_dma = 2,     // Minimal queue size for DMA
};

// buffers
#ifdef STRIP_LENGTH_1
DMA_ATTR static uint8_t strip_buffer_1[STRIP_LENGTH_1 * STRIP_NUM_COLORS] __attribute__((aligned(16)));
#endif
#ifdef STRIP_LENGTH_2
DMA_ATTR static uint8_t strip_buffer_2[STRIP_LENGTH_2 * STRIP_NUM_COLORS] __attribute__((aligned(16)));
#endif
#ifdef STRIP_LENGTH_3
DMA_ATTR static uint8_t strip_buffer_3[STRIP_LENGTH_3 * STRIP_NUM_COLORS] __attribute__((aligned(16)));
#endif
#ifdef STRIP_LENGTH_4
DMA_ATTR static uint8_t strip_buffer_4[STRIP_LENGTH_4 * STRIP_NUM_COLORS] __attribute__((aligned(16)));
#endif

static const rmt_transmit_config_t strip_tx_conf = {
    .loop_count = 0,
};

static const uint8_t font_5x7[] = {
    // Space (32)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ! (33)
    0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x08,
    // " (34)
    0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00,
    // # (35)
    0x14, 0x14, 0x3E, 0x14, 0x3E, 0x14, 0x14,
    // $ (36)
    0x08, 0x3E, 0x28, 0x3E, 0x0A, 0x3E, 0x08,
    // % (37)
    0x30, 0x32, 0x04, 0x08, 0x10, 0x26, 0x06,
    // & (38)
    0x18, 0x24, 0x28, 0x10, 0x2A, 0x24, 0x1A,
    // ' (39)
    0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00,
    // ( (40)
    0x04, 0x08, 0x10, 0x10, 0x10, 0x08, 0x04,
    // ) (41)
    0x10, 0x08, 0x04, 0x04, 0x04, 0x08, 0x10,
    // * (42)
    0x00, 0x08, 0x2A, 0x1C, 0x2A, 0x08, 0x00,
    // + (43)
    0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00,
    // , (44)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x10,
    // - (45)
    0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00,
    // . (46)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
    // / (47)
    0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
    // 0 (48)
    0x1C, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C,
    // 1 (49)
    0x08, 0x18, 0x28, 0x08, 0x08, 0x08, 0x3E,
    // 2 (50)
    0x1C, 0x22, 0x02, 0x0C, 0x10, 0x20, 0x3E,
    // 3 (51)
    0x3E, 0x02, 0x04, 0x0C, 0x02, 0x22, 0x1C,
    // 4 (52)
    0x04, 0x0C, 0x14, 0x24, 0x3E, 0x04, 0x04,
    // 5 (53)
    0x3E, 0x20, 0x3C, 0x02, 0x02, 0x22, 0x1C,
    // 6 (54)
    0x0C, 0x10, 0x20, 0x3C, 0x22, 0x22, 0x1C,
    // 7 (55)
    0x3E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x20,
    // 8 (56)
    0x1C, 0x22, 0x22, 0x1C, 0x22, 0x22, 0x1C,
    // 9 (57)
    0x1C, 0x22, 0x22, 0x1E, 0x02, 0x04, 0x18,
    // : (58)
    0x00, 0x00, 0x08, 0x00, 0x00, 0x08, 0x00,
    // ; (59)
    0x00, 0x00, 0x08, 0x00, 0x00, 0x08, 0x10,
    // < (60)
    0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02,
    // = (61)
    0x00, 0x00, 0x3E, 0x00, 0x3E, 0x00, 0x00,
    // > (62)
    0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10,
    // ? (63)
    0x1C, 0x22, 0x02, 0x04, 0x08, 0x00, 0x08,
    // @ (64)
    0x1C, 0x22, 0x02, 0x1A, 0x2A, 0x2A, 0x1C,
    // A (65)
    0x08, 0x14, 0x22, 0x22, 0x3E, 0x22, 0x22,
    // B (66)
    0x3C, 0x22, 0x22, 0x3C, 0x22, 0x22, 0x3C,
    // C (67)
    0x1C, 0x22, 0x20, 0x20, 0x20, 0x22, 0x1C,
    // D (68)
    0x3C, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3C,
    // E (69)
    0x3E, 0x20, 0x20, 0x3C, 0x20, 0x20, 0x3E,
    // F (70)
    0x3E, 0x20, 0x20, 0x3C, 0x20, 0x20, 0x20,
    // G (71)
    0x1C, 0x22, 0x20, 0x20, 0x26, 0x22, 0x1C,
    // H (72)
    0x22, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x22,
    // I (73)
    0x3E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3E,
    // J (74)
    0x02, 0x02, 0x02, 0x02, 0x22, 0x22, 0x1C,
    // K (75)
    0x22, 0x24, 0x28, 0x30, 0x28, 0x24, 0x22,
    // L (76)
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3E,
    // M (77)
    0x22, 0x36, 0x2A, 0x2A, 0x22, 0x22, 0x22,
    // N (78)
    0x22, 0x22, 0x32, 0x2A, 0x26, 0x22, 0x22,
    // O (79)
    0x1C, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C,
    // P (80)
    0x3C, 0x22, 0x22, 0x3C, 0x20, 0x20, 0x20,
    // Q (81)
    0x1C, 0x22, 0x22, 0x22, 0x2A, 0x24, 0x1A,
    // R (82)
    0x3C, 0x22, 0x22, 0x3C, 0x28, 0x24, 0x22,
    // S (83)
    0x1C, 0x22, 0x20, 0x1C, 0x02, 0x22, 0x1C,
    // T (84)
    0x3E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    // U (85)
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C,
    // V (86)
    0x22, 0x22, 0x22, 0x22, 0x22, 0x14, 0x08,
    // W (87)
    0x22, 0x22, 0x22, 0x2A, 0x2A, 0x36, 0x22,
    // X (88)
    0x22, 0x22, 0x14, 0x08, 0x14, 0x22, 0x22,
    // Y (89)
    0x22, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08,
    // Z (90)
    0x3E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x3E,
    // [ (91)
    0x3E, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3E,
    // \ (92)
    0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02,
    // ] (93)
    0x3E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x3E,
    // ^ (94)
    0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x00,
    // _ (95)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E,
    // ` (96)
    0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00,
    // a (97)
    0x00, 0x00, 0x1C, 0x02, 0x1E, 0x22, 0x1E,
    // b (98)
    0x20, 0x20, 0x3C, 0x22, 0x22, 0x22, 0x3C,
    // c (99)
    0x00, 0x00, 0x1C, 0x22, 0x20, 0x22, 0x1C,
    // d (100)
    0x02, 0x02, 0x1E, 0x22, 0x22, 0x22, 0x1E,
    // e (101)
    0x00, 0x00, 0x1C, 0x22, 0x3E, 0x20, 0x1C,
    // f (102)
    0x0C, 0x12, 0x10, 0x38, 0x10, 0x10, 0x10,
    // g (103)
    0x00, 0x00, 0x1E, 0x22, 0x22, 0x1E, 0x02, 0x1C,
    // h (104)
    0x20, 0x20, 0x3C, 0x22, 0x22, 0x22, 0x22,
    // i (105)
    0x08, 0x00, 0x18, 0x08, 0x08, 0x08, 0x1C,
    // j (106)
    0x04, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x24, 0x18,
    // k (107)
    0x20, 0x20, 0x22, 0x24, 0x38, 0x24, 0x22,
    // l (108)
    0x18, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1C,
    // m (109)
    0x00, 0x00, 0x36, 0x2A, 0x2A, 0x2A, 0x22,
    // n (110)
    0x00, 0x00, 0x3C, 0x22, 0x22, 0x22, 0x22,
    // o (111)
    0x00, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x1C,
    // p (112)
    0x00, 0x00, 0x3C, 0x22, 0x22, 0x3C, 0x20, 0x20,
    // q (113)
    0x00, 0x00, 0x1E, 0x22, 0x22, 0x1E, 0x02, 0x02,
    // r (114)
    0x00, 0x00, 0x3C, 0x22, 0x20, 0x20, 0x20,
    // s (115)
    0x00, 0x00, 0x1E, 0x20, 0x1C, 0x02, 0x3C,
    // t (116)
    0x10, 0x10, 0x38, 0x10, 0x10, 0x12, 0x0C,
    // u (117)
    0x00, 0x00, 0x22, 0x22, 0x22, 0x22, 0x1E,
    // v (118)
    0x00, 0x00, 0x22, 0x22, 0x22, 0x14, 0x08,
    // w (119)
    0x00, 0x00, 0x22, 0x22, 0x2A, 0x2A, 0x14,
    // x (120)
    0x00, 0x00, 0x22, 0x14, 0x08, 0x14, 0x22,
    // y (121)
    0x00, 0x00, 0x22, 0x22, 0x22, 0x1E, 0x02, 0x1C,
    // z (122)
    0x00, 0x00, 0x3E, 0x04, 0x08, 0x10, 0x3E,
    // { (123)
    0x0C, 0x10, 0x10, 0x30, 0x10, 0x10, 0x0C,
    // | (124)
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    // } (125)
    0x18, 0x04, 0x04, 0x06, 0x04, 0x04, 0x18,
    // ~ (126)
    0x00, 0x00, 0x00, 0x18, 0x24, 0x00, 0x00,
    // DEL (127)
    0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E
};



strip_t *strip_create(int idx, gpio_num_t pin, uint32_t size, bool dma) {
    strip_t *strip = heap_caps_calloc(1, sizeof(strip_t), MALLOC_CAP_DEFAULT);
    if (!strip) {
        ERR("Failed to allocate strip");
        return NULL;
    }

    strip->pin = pin;
    strip->size = size;
    strip->dma = dma;

    switch (idx) {
        case 0:
#ifdef STRIP_LENGTH_1
            strip->buffer = strip_buffer_1;
#endif
            break;
        case 1:
#ifdef STRIP_LENGTH_2
            strip->buffer = strip_buffer_2;
#endif
            break;
        case 2:
#ifdef STRIP_LENGTH_3
            strip->buffer = strip_buffer_3;
#endif
            break;
        case 3:
#ifdef STRIP_LENGTH_4
            strip->buffer = strip_buffer_4;
#endif
            break;
        default:
            free(strip);
            return NULL;
    }

    rmt_tx_channel_config_t rmt_config = {
        .gpio_num = pin,
        .clk_src = strip_conf.clock_source,
        .mem_block_symbols = dma ? strip_conf.blk_dma : strip_conf.blk_rmt,
        .resolution_hz = strip_conf.resolution_hz,
        .trans_queue_depth = dma ? strip_conf.queue_dma : strip_conf.queue_rmt,
        .flags.invert_out = false,
        .flags.with_dma = dma,
    };

    esp_err_t ret = rmt_new_tx_channel(&rmt_config, &strip->channel);
    if (ret != ESP_OK) {
        ERR("Failed to create RMT channel for pin %d: %s", pin, esp_err_to_name(ret));
        free(strip);
        return NULL;
    }

    ret = encoder_new(&strip->encoder);
    if (ret != ESP_OK) {
        ERR("Failed to create encoder for strip %d: %d", idx, ret);
        rmt_del_channel(strip->channel);
        free(strip);
        return NULL;
    }

    strips[idx] = strip;  // Store pointer to strip
    return strip;
}

esp_err_t strip_set_pixel_rgb(strip_t *strip, uint32_t pixel, uint8_t r, uint8_t g, uint8_t b) {
    strip->buffer[pixel * strip_conf.num_colors + 0] = g & 0xFF;
    strip->buffer[pixel * strip_conf.num_colors + 1] = r & 0xFF;
    strip->buffer[pixel * strip_conf.num_colors + 2] = b & 0xFF;
    return ESP_OK;
}

esp_err_t strip_set_all_rgb(strip_t *strip, uint8_t r, uint8_t g, uint8_t b) {
        for (uint32_t i = 0; i < strip->size; i++) {
            strip->buffer[i * strip_conf.num_colors + 0] = g & 0xFF;
            strip->buffer[i * strip_conf.num_colors + 1] = r & 0xFF;
            strip->buffer[i * strip_conf.num_colors + 2] = b & 0xFF;
        }
    return ESP_OK;
}

esp_err_t strip_set_range_rgb(
    strip_t *strip, uint32_t pixel_start, uint32_t pixel_end, uint8_t r, uint8_t g, uint8_t b) {
        for (uint32_t i = pixel_start; i < pixel_end; i++) {
            strip->buffer[i * strip_conf.num_colors + 0] = g & 0xFF;
            strip->buffer[i * strip_conf.num_colors + 1] = r & 0xFF;
            strip->buffer[i * strip_conf.num_colors + 2] = b & 0xFF;
        }
    return ESP_OK;
}

esp_err_t strip_enable(strip_t *strip) {
    rmt_enable(strip->channel);
    return ESP_OK;
}

esp_err_t strip_disable(strip_t *strip) {
    rmt_disable(strip->channel);
    return ESP_OK;
}

esp_err_t strip_refresh(strip_t *strip) {
    rmt_transmit(
        strip->channel, strip->encoder, strip->buffer, strip->size * strip_conf.num_colors,
        &strip_tx_conf);
    rmt_tx_wait_all_done(strip->channel, portMAX_DELAY);
    return ESP_OK;
}

esp_err_t strip_clear(strip_t *strip) {
    memset(strip->buffer, 0, strip->size * strip_conf.num_colors);
    return ESP_OK;
}

// grid operations

#define STRIP_GRID_WIDTH 32
#define STRIP_GRID_HEIGHT 8
#define STRIP_GRID_SERPENTINE true

int32_t strip_xy_to_index(uint32_t x, uint32_t y) {
    if (x >= STRIP_GRID_WIDTH || y >= STRIP_GRID_HEIGHT) {
        return -1;
    }

    uint32_t index;
    if (STRIP_GRID_SERPENTINE) {
        // For serpentine pattern, reverse direction for odd columns
        if (x % 2 == 0) {
            index = x * STRIP_GRID_HEIGHT + y;
        } else {
            index = x * STRIP_GRID_HEIGHT + (STRIP_GRID_HEIGHT - 1 - y);
        }
    } else {
        // Standard vertical-first pattern
        index = x * STRIP_GRID_HEIGHT + y;
    }

    return index;
}

esp_err_t strip_set_pixel_xy(strip_t *strip, uint32_t x, uint32_t y, uint8_t r, uint8_t g, uint8_t b) {
    int32_t index = strip_xy_to_index(x, y);
    if (index >= 0 && index < STRIP_LENGTH_1) {
        return strip_set_pixel_rgb(strip, index, r, g, b);
        vTaskDelay(pdMS_TO_TICKS(1));
    }
    return ESP_FAIL;
}

esp_err_t strip_draw_line(strip_t *strip, int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint8_t r, uint8_t g, uint8_t b) {
    int16_t dx = abs(x1 - x0);
    int16_t dy = abs(y1 - y0);
    int16_t sx = (x0 < x1) ? 1 : -1;
    int16_t sy = (y0 < y1) ? 1 : -1;
    int16_t err = dx - dy;
    int16_t e2;

    while (1) {
        // Only draw if within bounds
        if (x0 >= 0 && x0 < STRIP_GRID_WIDTH && y0 >= 0 && y0 < STRIP_GRID_HEIGHT) {
            //INFO("Drawing dot at %d, %d", x0, y0);
            strip_set_pixel_xy(strip, x0, y0, r, g, b);
        }

        if (x0 == x1 && y0 == y1) break;
        e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x0 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y0 += sy;
        }
    }

    return ESP_OK;
}

esp_err_t strip_draw_char(strip_t *strip, int16_t x, int16_t y, char c, uint8_t r, uint8_t g, uint8_t b) {
    if (c < 32 || c > 127) {
        c = '?';
    }
    // Calculate offset into font data
    int char_index = c - 32;
    const uint8_t *char_data = &font_5x7[char_index * 7];
    
    // Draw each row of the character
    for (int row = 0; row < 7; row++) {
        uint8_t row_data = char_data[row];
        
        // Draw each pixel in the row
        for (int col = 0; col < 5; col++) {
            if (row_data & (0x20 >> col)) {
                int pixel_x = x + col;
                int pixel_y = y + row;
                
                if (pixel_x >= 0 && pixel_x < STRIP_GRID_WIDTH && pixel_y >= 0 && pixel_y < STRIP_GRID_HEIGHT) {
                    strip_set_pixel_xy(strip, pixel_x, pixel_y, r, g, b);
                }
            }
        }
    }
    
    return ESP_OK;
}